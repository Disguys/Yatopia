From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sun, 11 Oct 2020 12:30:35 +0800
Subject: [PATCH] OpenCL base

Patch used for OpenCL computing
Using GlowStoneMC implementation of OpenCompute API with JOCL

diff --git a/pom.xml b/pom.xml
index fd15e54ea87581c61566b7ed4620435fac579bab..c246d2883d1c172c9f7774f53407eb77a6540443 100644
--- a/pom.xml
+++ b/pom.xml
@@ -111,6 +111,17 @@
             <artifactId>netty-all</artifactId>
             <version>4.1.50.Final</version>
         </dependency>
+        <!-- OpenCL -->
+        <dependency>
+            <groupId>org.jogamp.gluegen</groupId>
+            <artifactId>gluegen-rt-main</artifactId>
+            <version>2.3.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jogamp.jocl</groupId>
+            <artifactId>jocl-main</artifactId>
+            <version>2.3.2</version>
+        </dependency>
         <!-- deprecated API depend -->
         <dependency>
             <groupId>com.googlecode.json-simple</groupId>
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c3b2a77300bce04139741c8d79bb7c0d8199f403..09982930f614a49961fd116c9c59852b4cd0037f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -56,6 +56,8 @@ import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import net.yatopia.server.opencl.OpenCompute;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -838,6 +840,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         LOGGER.info("Closing Thread Pool");
         SystemUtils.shutdownServerThreadPool(); // Paper
         LOGGER.info("Closing Server");
+        OpenCompute.release(); // Yatopia
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
         } catch (Exception e) {
diff --git a/src/main/java/net/yatopia/server/YatopiaConfig.java b/src/main/java/net/yatopia/server/YatopiaConfig.java
index 893487d52aa58f4360cadfb83f87cf9d8396134e..ee0ad28add93b8ee5be2814884dd5a0809c4890a 100644
--- a/src/main/java/net/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/net/yatopia/server/YatopiaConfig.java
@@ -14,6 +14,7 @@ import java.util.logging.Level;
 import java.util.regex.Pattern;
 import net.minecraft.server.MinecraftServer;
 import net.yatopia.server.lighting.LightEngineType;
+import net.yatopia.server.opencl.OpenCLCommand;
 import org.bukkit.Bukkit;
 import org.bukkit.command.Command;
 import org.bukkit.configuration.InvalidConfigurationException;
@@ -47,6 +48,7 @@ public class YatopiaConfig {
         verbose = getBoolean("verbose", false);
         commands = new HashMap<>();
         commands.put("nspt", new NSPTCommand("nspt"));
+        commands.put("opencl", new OpenCLCommand("opencl"));
 
         version = getInt("config-version", 1);
         set("config-version", 1);
@@ -256,12 +258,25 @@ public class YatopiaConfig {
     }
 
     public static LightEngineType lightEngineType = LightEngineType.VANILLA;
+
     private static void lightEngineType() {
         String type = getString("settings.light-engine.type", lightEngineType.name());
         try {
             lightEngineType = LightEngineType.valueOf(type);
-        } catch (IllegalArgumentException e){
+        } catch (IllegalArgumentException e) {
             Bukkit.getLogger().warning("Could not detect light engine type from \"" + type + "\", fallback to default " + lightEngineType.name());
         }
     }
+
+    public static boolean useOpenCL = true;
+    public static int openCLDeviceOverride = -1;
+    public static boolean openCLOverride = false;
+    public static int openCLTestSize = 1048576;
+
+    private static void openCL() {
+        useOpenCL = getBoolean("settings.opencl.enabled", useOpenCL);
+        openCLDeviceOverride = getInt("settings.opencl.device-override", openCLDeviceOverride);
+        openCLOverride = getBoolean("settings.opencl.override", openCLOverride);
+        openCLTestSize = getInt("settings.opencl.test-size", openCLTestSize);
+    }
 }
diff --git a/src/main/java/net/yatopia/server/opencl/BasicCPUBenchmark.java b/src/main/java/net/yatopia/server/opencl/BasicCPUBenchmark.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6195b8a4d7e44bf332358645978affb68e39aa4
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/BasicCPUBenchmark.java
@@ -0,0 +1,38 @@
+package net.yatopia.server.opencl;
+
+import io.netty.util.internal.ThreadLocalRandom;
+import net.yatopia.server.YatopiaConfig;
+import net.yatopia.server.list.GlueList;
+
+import java.util.concurrent.CompletableFuture;
+
+public class BasicCPUBenchmark {
+
+    private static int WORK_SIZE = YatopiaConfig.openCLTestSize;
+
+    public static CompletableFuture<CPUBenchmarkResult> benchmark() {
+        CompletableFuture<CPUBenchmarkResult> future = new CompletableFuture<>();
+        GlueList<Long> timingList = new GlueList<>();
+        try {
+            for (int i = 0; i < 10; i++) {
+                final long[] testData1 = new long[WORK_SIZE];
+                final long[] testData2 = new long[WORK_SIZE];
+                for (int h = 0; h < WORK_SIZE; h++) {
+                    testData1[h] = ThreadLocalRandom.current().nextLong();
+                    testData2[h] = ThreadLocalRandom.current().nextLong();
+                }
+                long startTime = System.nanoTime();
+                long[] result = new long[WORK_SIZE];
+                for (int h = 0; h < WORK_SIZE; h++) {
+                    result[h] = (((testData1[h] * h) << 2) + (testData2[h] % 2) / (h + 1) + (h >> 2) / ((h + 1) << 4));
+                }
+                timingList.add(System.nanoTime() - startTime);
+            }
+            future.complete(new CPUBenchmarkResult(timingList));
+        } catch (Throwable t) {
+            future.completeExceptionally(t);
+        }
+
+        return future;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/opencl/BasicOpenCLBenchmark.java b/src/main/java/net/yatopia/server/opencl/BasicOpenCLBenchmark.java
new file mode 100644
index 0000000000000000000000000000000000000000..187b6f38f4bd6d9f44ec7c4e5d845f55aeaf8dd4
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/BasicOpenCLBenchmark.java
@@ -0,0 +1,86 @@
+package net.yatopia.server.opencl;
+
+import com.jogamp.opencl.CLBuffer;
+import com.jogamp.opencl.CLCommandQueue;
+import com.jogamp.opencl.CLEventList;
+import com.jogamp.opencl.CLKernel;
+import com.jogamp.opencl.CLProgram;
+import io.netty.util.internal.ThreadLocalRandom;
+import net.yatopia.server.YatopiaConfig;
+import net.yatopia.server.list.GlueList;
+
+import java.nio.LongBuffer;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+
+import static com.jogamp.opencl.CLEvent.ProfilingCommand.*;
+
+public class BasicOpenCLBenchmark {
+
+    private static int WORK_SIZE = YatopiaConfig.openCLTestSize;
+    private static CLBuffer<LongBuffer> longBuffer1 = null;
+    private static CLBuffer<LongBuffer> longBuffer2 = null;
+    private static CLBuffer<LongBuffer> longBuffer3 = null;
+
+
+    public static CompletableFuture<OpenCLBenchmarkResult> benchmark(OpenCompute openCompute) {
+        CompletableFuture<OpenCLBenchmarkResult> future = new CompletableFuture<>();
+        GlueList<Long> gpuTimingList = new GlueList<>();
+        GlueList<Long> cpuTimingList = new GlueList<>();
+        GlueList<Long> latencyTimingList = new GlueList<>();
+        try {
+            OpenCompute.OPENCL_EXECUTOR.execute(() -> {
+                final long[] testData1 = new long[WORK_SIZE];
+                final long[] testData2 = new long[WORK_SIZE];
+                CLProgram program = openCompute.getProgram("net/yatopia/server/opencl/SpeedTest.cl");
+                for (int i = 0; i < 10; i++) {
+                    for (int h = 0; h < WORK_SIZE; h++) {
+                        testData1[h] = ThreadLocalRandom.current().nextLong();
+                        testData2[h] = ThreadLocalRandom.current().nextLong();
+                    }
+                    long startTime = System.nanoTime();
+                    CLKernel kernel = null;
+                    CLEventList events = null;
+                    try {
+                        if (longBuffer1 != null) { longBuffer1 = openCompute.getContext().createLongBuffer(WORK_SIZE); }
+                        if (longBuffer2 != null) { longBuffer2 = openCompute.getContext().createLongBuffer(WORK_SIZE); }
+                        if (longBuffer3 != null) { longBuffer3 = openCompute.getContext().createLongBuffer(WORK_SIZE); }
+                        longBuffer1.getBuffer().put(testData1);
+                        longBuffer2.getBuffer().put(testData2);
+                        kernel = openCompute.getKernel(program, "test");
+                        kernel.putArg(longBuffer1)
+                                .putArg(longBuffer2)
+                                .putArg(longBuffer3);
+                        CLCommandQueue clCommandQueue = openCompute.getQueue();
+                        events = new CLEventList(null, 1);
+                        clCommandQueue.put1DRangeKernel(kernel, 0,
+                                openCompute.getGlobalSize(WORK_SIZE), openCompute.getLocalSize(), events)
+                                .putReadBuffer(longBuffer3, true)
+                                .putWaitForEvents(events, true);
+
+                        long gpuTiming = events.getEvent(0).getProfilingInfo(END) - events.getEvent(0).getProfilingInfo(START);
+                        long cpuTiming = System.nanoTime() - startTime;
+                        long latencyTiming = cpuTiming - gpuTiming;
+                        gpuTimingList.add(gpuTiming);
+                        cpuTimingList.add(cpuTiming);
+                        latencyTimingList.add(latencyTiming);
+                    } finally {
+                        if (kernel != null && !kernel.isReleased()) kernel.release();
+                        if (events != null && !events.isReleased()) events.release();
+                    }
+                }
+
+                future.complete(new OpenCLBenchmarkResult(gpuTimingList, cpuTimingList, latencyTimingList, openCompute));
+            });
+        } catch (Throwable t) {
+            future.completeExceptionally(t);
+        } finally {
+            if (longBuffer1 != null && !longBuffer1.isReleased()) longBuffer1.release();
+            if (longBuffer2 != null && !longBuffer2.isReleased()) longBuffer2.release();
+            if (longBuffer3 != null && !longBuffer3.isReleased()) longBuffer3.release();
+        }
+
+        return future;
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/opencl/CPUBenchmarkResult.java b/src/main/java/net/yatopia/server/opencl/CPUBenchmarkResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..a41d27ce71dd38dee9c6d46d9b13fcfb5ff99cff
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/CPUBenchmarkResult.java
@@ -0,0 +1,26 @@
+package net.yatopia.server.opencl;
+
+import net.yatopia.server.list.GlueList;
+
+public class CPUBenchmarkResult {
+    private final long timing;
+
+    CPUBenchmarkResult(GlueList timing) {
+        this.timing = CalculateAverage(timing);
+    }
+
+    public long getTiming() {
+        return timing;
+    }
+
+    private long CalculateAverage(GlueList list) {
+        long sum = 0;
+        if (!list.isEmpty()) {
+            for (int i = 0; i < list.size(); i++) {
+                sum += (long) list.get(i);
+            }
+            return sum / list.size();
+        }
+        return sum;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/opencl/OpenCLBenchmarkResult.java b/src/main/java/net/yatopia/server/opencl/OpenCLBenchmarkResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..bd629a02f509b63b28d61ebf32b3910fc4070b35
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/OpenCLBenchmarkResult.java
@@ -0,0 +1,40 @@
+package net.yatopia.server.opencl;
+
+import net.yatopia.server.list.GlueList;
+
+public class OpenCLBenchmarkResult {
+    private final long gpuTiming;
+    private final long cpuTiming;
+    private final long latencyTiming;
+    public final OpenCompute openCompute;
+
+    OpenCLBenchmarkResult(GlueList gpuTiming, GlueList cpuTiming, GlueList latencyTiming, OpenCompute openCompute) {
+        this.gpuTiming = CalculateAverage(gpuTiming);
+        this.cpuTiming = CalculateAverage(cpuTiming);
+        this.latencyTiming = CalculateAverage(latencyTiming);
+        this.openCompute = openCompute;
+    }
+
+    public long getGpuTiming() {
+            return gpuTiming;
+        }
+
+    public long getCpuTiming() {
+            return cpuTiming;
+        }
+
+    public long getLatencyTiming() {
+            return latencyTiming;
+        }
+
+    private long CalculateAverage(GlueList list) {
+        long sum = 0;
+        if (!list.isEmpty()) {
+            for (int i = 0; i < list.size(); i++) {
+                sum += (long) list.get(i);
+            }
+            return sum / list.size();
+        }
+        return sum;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/opencl/OpenCLCommand.java b/src/main/java/net/yatopia/server/opencl/OpenCLCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2c4b95991f84d14d99d4213dad990c3bf4db771
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/OpenCLCommand.java
@@ -0,0 +1,84 @@
+package net.yatopia.server.opencl;
+
+import com.destroystokyo.paper.PaperCommand;
+import net.yatopia.server.YatopiaConfig;
+import org.apache.logging.log4j.LogManager;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.util.List;
+
+public class OpenCLCommand extends Command {
+
+    public OpenCLCommand(String name) {
+        super(name);
+        this.description = "OpenCL related post-launch functions";
+        this.usageMessage = "/opencl";
+        this.setPermission("bukkit.command.opencl");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (Boolean.parseBoolean(System.getProperty("Yatopia.OpenCLDebug", "true"))) {
+            return PaperCommand.getListMatchingLast(args, "info", "reload", "enable", "override");
+        }
+        return PaperCommand.getListMatchingLast(args, "info");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+
+        if (!YatopiaConfig.useOpenCL) {
+            sender.sendMessage("Your system does not support OpenCL, OpenCL has been explicitly disabled, or OpenCL yields no performance gains");
+            sender.sendMessage("Check logs for more info");
+            return true;
+        }
+
+        if (args.length <= 0) {
+            sender.sendMessage(String.format("Using %s for OpenCL acceleration", OpenCompute.getActiveInstance().getDevice().getName()));
+            return true;
+        }
+
+        if (args[0].equals("info")) {
+            sender.sendMessage(String.format("Using %s for OpenCL acceleration", OpenCompute.getActiveInstance().getDevice().getName()));
+            return true;
+        }
+
+        if (Boolean.parseBoolean(System.getProperty("Yatopia.OpenCLDebug", "true"))) {
+            if (args[0].equals("reload")) {
+                try {
+                    sender.sendMessage("Reloading OpenCL");
+                    sender.sendMessage("Shutting down OpenCL");
+                    OpenCompute.release();
+                    sender.sendMessage("Starting OpenCL");
+                    YatopiaConfig.useOpenCL = true;
+                    OpenCompute.init();
+                    sender.sendMessage("OpenCL has been successfully reloaded");
+                } catch (Exception e) {
+                    YatopiaConfig.useOpenCL = false;
+                    LogManager.getLogger().error(e);
+                    sender.sendMessage("Error Reloading OpenCL");
+                }
+                return true;
+            }
+
+            if (args[0].equals("enable")) {
+                sender.sendMessage("Enabling OpenCL");
+                YatopiaConfig.useOpenCL = true;
+                return true;
+            }
+
+            if (args[0].equals("override")) {
+                sender.sendMessage("Overriding OpenCL Performance Check");
+                YatopiaConfig.openCLOverride = true;
+                return true;
+            }
+        }
+
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/opencl/OpenCompute.java b/src/main/java/net/yatopia/server/opencl/OpenCompute.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a513bd81e4b5563a77c6645571a68146d216887
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/OpenCompute.java
@@ -0,0 +1,331 @@
+/*
+ * Glowstone Copyright (C) 2015-2020 The Glowstone Project.
+ * Glowstone Copyright (C) 2011-2014 Tad Hardesty.
+ * Lightstone Copyright (C) 2010-2011 Graham Edgecombe.
+ */
+
+package net.yatopia.server.opencl;
+
+import com.jogamp.opencl.CLCommandQueue;
+import com.jogamp.opencl.CLContext;
+import com.jogamp.opencl.CLDevice;
+import com.jogamp.opencl.CLKernel;
+import com.jogamp.opencl.CLPlatform;
+import com.jogamp.opencl.CLProgram;
+import com.jogamp.opencl.llb.impl.CLAbstractImpl;
+import net.yatopia.server.YatopiaConfig;
+import net.yatopia.server.list.GlueList;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicLong;
+
+public class OpenCompute implements Closeable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final ClassLoader CLASS_LOADER = OpenCompute.class.getClassLoader();
+    static final ExecutorService OPENCL_EXECUTOR = Executors.newCachedThreadPool(new ThreadFactory() {
+        private AtomicLong serial = new AtomicLong(0);
+
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread thread = new Thread(r);
+            thread.setName("YatopiaCL-" + serial.getAndIncrement());
+            thread.setPriority(Thread.NORM_PRIORITY - 1);
+            thread.setDaemon(true);
+            return thread;
+        }
+    });
+
+    private final File openCLDir;
+    private final CLPlatform platform;
+    private final CLContext context;
+    private final CLDevice device;
+    private final CLCommandQueue queue;
+    private ConcurrentHashMap<String, CLProgram> programs;
+
+    private static OpenCompute activeInstance = null;
+
+    public static OpenCompute getActiveInstance() {
+        return activeInstance;
+    }
+
+    public static synchronized void release() {
+        LOGGER.info("Yatopia OpenCL: Shutting down");
+        if (activeInstance != null)
+            activeInstance.close();
+        YatopiaConfig.useOpenCL = false;
+        activeInstance = null;
+    }
+
+    public CLPlatform getPlatform() {
+        return platform;
+    }
+
+    public CLContext getContext() {
+        return context;
+    }
+
+    public CLDevice getDevice() {
+        return device;
+    }
+
+    public CLCommandQueue getQueue() {
+        return queue;
+    }
+
+    /**
+     * Initializes the {@link CLContext}, {@link CLDevice} and {@link CLCommandQueue} for the given
+     * {@link CLPlatform}.
+     *
+     * @param device the {@link CLDevice} to use
+     */
+    private OpenCompute(CLDevice device) {
+        this(device, false);
+    }
+
+    private OpenCompute(CLDevice device, boolean profilingEnabled) {
+        openCLDir = new File("opencl");
+
+        programs = new ConcurrentHashMap<>();
+        platform = device.getPlatform();
+        context = CLContext.create(device);
+        this.device = device;
+        try {
+            if (profilingEnabled)
+                queue = device.createCommandQueue(CLCommandQueue.Mode.PROFILING_MODE, CLCommandQueue.Mode.OUT_OF_ORDER_MODE);
+            else
+                queue = device.createCommandQueue(CLCommandQueue.Mode.OUT_OF_ORDER_MODE);
+        } catch (Exception e) {
+            LOGGER.info("Failed to initialize {}", device.getName());
+        }
+    }
+
+    /**
+     * Returns an OpenCL program, loading it synchronously if it's not in cache.
+     *
+     * @param name the program filename
+     * @return the OpenCL program, or null if there isn't a valid program with that name
+     */
+    public CLProgram getProgram(String name) {
+        if (programs.containsKey(name)) {
+            return programs.get(name);
+        } else {
+            synchronized (this) {
+                if (programs.containsKey(name))
+                    return programs.get(name);
+                if (openCLDir.exists() && openCLDir.isDirectory()) {
+                    File file = new File(openCLDir, name);
+                    if (file.exists()) {
+                        try (InputStream input = new FileInputStream(file)) {
+                            CLProgram program = context.createProgram(input).build();
+                            programs.put(name, program);
+                            return program;
+                        } catch (IOException ex) {
+                            LOGGER.log(Level.WARN,
+                                    "Could not load custom OpenCL program.", ex);
+                        }
+                    }
+                }
+                try (InputStream input = CLASS_LOADER
+                        .getResourceAsStream("builtin/opencl/" + name)) {
+                    CLProgram program = context.createProgram(input).build();
+                    programs.put(name, program);
+                    return program;
+                } catch (IOException ex) {
+                    LOGGER.log(Level.WARN,
+                            "Could not load builtin OpenCL program.", ex);
+                }
+            }
+        }
+        return null;
+    }
+
+    public CLKernel getKernel(CLProgram program, String name) {
+        return program.createCLKernel(name);
+    }
+
+    /**
+     * Initializes OpenCompute API with settings defined in yatopia.yml
+     */
+    public static synchronized void init() {
+        if (YatopiaConfig.useOpenCL) {
+            LOGGER.info("Initializing OpenCL...");
+            if (!CLAbstractImpl.isAvailable()) {
+                LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                        "See if driver updates are available.");
+                return;
+            }
+
+            CLPlatform[] platforms = CLPlatform.listCLPlatforms();
+            LOGGER.debug(String.format("Found %d platforms", platforms.length));
+            List<CLDevice> devices = new GlueList<>();
+            List<CompletableFuture<OpenCLBenchmarkResult>> deviceBenchmarks = new GlueList<>();
+            for (int i = 0; i < platforms.length; i++) {
+                CLPlatform platform = platforms[i];
+                LOGGER.debug("Platform {}: Vendor string: {} ", i, platform.getVendor());
+                LOGGER.debug("Platform {}: Profile string: {}", i, platform.getProfile());
+                LOGGER.debug("Platform {}: Version string: {} ", i, platform.getVersion());
+                LOGGER.debug("Platform {}: Name string: {} ", i, platform.getName());
+                LOGGER.debug("Platform {}: Available extensions: {} ", i, platform.getExtensions());
+                CLDevice[] platformDevices = platform.listCLDevices();
+                devices.addAll(Arrays.asList(platformDevices));
+            }
+
+            LOGGER.info("Found {} devices", devices.size());
+            if (devices.isEmpty()) {
+                LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                        "See if driver updates are available.");
+                return;
+            }
+
+            for (int i = 0, deviceCount = devices.size(); i < deviceCount; i++) {
+                CLDevice device = devices.get(i);
+                CLPlatform platform = device.getPlatform();
+                int platformID = -1;
+                for (int j = 0; j < platforms.length; j++)
+                    if (platforms[j] == platform) {
+                        platformID = j;
+                        break;
+                    }
+                LOGGER.info("Device {}: {} ", i, device.getName());
+                LOGGER.debug("Device {} of Platform {}: Version string: {} ", i, platformID, device.getVersion());
+                LOGGER.debug("Device {} of Platform {}: C-Version string: {} ", i, platformID, device.getCVersion());
+                LOGGER.debug("Device {} of Platform {}: Driver version string: {} ", i, platformID, device.getDriverVersion());
+                LOGGER.debug("Device {} of Platform {}: Profile string: {} ", i, platformID, device.getProfile());
+                LOGGER.debug("Device {} of Platform {}: Device type: {} ", i, platformID, device.getType());
+                LOGGER.debug("Device {} of Platform {}: Available extensions: {}", i, platformID, device.getExtensions());
+                LOGGER.debug("Device {} of Platform {}: Execution capabilities: {}", i, platformID, device.getExecutionCapabilities());
+            }
+
+            if (YatopiaConfig.openCLDeviceOverride < -1 || YatopiaConfig.openCLDeviceOverride >= devices.size()) {
+                LOGGER.warn("Invalid override in configuration, ignoring");
+                YatopiaConfig.openCLDeviceOverride = -1;
+            }
+            if (YatopiaConfig.openCLDeviceOverride != -1) {
+                LOGGER.info("Overrides detected, using device {}", YatopiaConfig.openCLDeviceOverride);
+                activeInstance = new OpenCompute(devices.get(YatopiaConfig.openCLDeviceOverride));
+            } else {
+                LOGGER.info("No overrides defined, sorting devices by benchmark results...");
+                for (CLDevice device : devices) {
+                    OpenCompute openCompute = new OpenCompute(device, true);
+                    deviceBenchmarks.add(BasicOpenCLBenchmark.benchmark(openCompute).handle((openCLBenchmarkResult, throwable) -> {
+                        if (throwable != null)
+                            LOGGER.info("A device failed to benchmark, device information unavailable", throwable);
+                        openCompute.close();
+                        return openCLBenchmarkResult;
+                    }));
+                }
+                deviceBenchmarks.sort((o1, o2) -> {
+                    OpenCLBenchmarkResult openCLBenchmarkResult1 = o1.join();
+                    OpenCLBenchmarkResult openCLBenchmarkResult2 = o2.join();
+                    int gpuTimingCompare = Long.compare(openCLBenchmarkResult1.getGpuTiming(), openCLBenchmarkResult2.getGpuTiming());
+                    int cpuTimingCompare = Long.compare(openCLBenchmarkResult1.getCpuTiming(), openCLBenchmarkResult2.getCpuTiming());
+                    if (gpuTimingCompare != 0) return gpuTimingCompare;
+                    else return cpuTimingCompare;
+                });
+                deviceBenchmarks.removeIf(future -> future.join() == null);
+
+                if (deviceBenchmarks.isEmpty()) {
+                    LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                            "See if driver updates are available.");
+                    return;
+                }
+
+                LOGGER.info("Benchmark results: ");
+                for (int i = 0, size = deviceBenchmarks.size(); i < size; i++) {
+                    OpenCLBenchmarkResult openCLBenchmarkResult = deviceBenchmarks.get(i).join();
+                    LOGGER.info("{}: {}ms compute time, {}ms round trip, {}ms latency",
+                            openCLBenchmarkResult.openCompute.getDevice().getName(), openCLBenchmarkResult.getGpuTiming() / 1_000_000.0, openCLBenchmarkResult.getCpuTiming() / 1_000_000.0,
+                            openCLBenchmarkResult.getLatencyTiming() / 1_000_000.0);
+                    LOGGER.debug("{}: CLPlatform {} on device CLDevice {}",
+                            openCLBenchmarkResult.openCompute.getDevice().getName(), openCLBenchmarkResult.openCompute.getPlatform(), openCLBenchmarkResult.openCompute.getDevice());
+                }
+
+                double CPUResult = BasicCPUBenchmark.benchmark().join().getTiming() / 1_000_000.0;
+                OpenCLBenchmarkResult fastestdeivce = deviceBenchmarks.get(0).join();
+                LOGGER.info("Native CPU: {}ms round trip", CPUResult);
+                if (fastestdeivce.getCpuTiming() / 1_000_000.0 < CPUResult || YatopiaConfig.openCLOverride) {
+                    CLDevice device = fastestdeivce.openCompute.device;
+                    LOGGER.info("OpenCL: Using {}", device.getName());
+                    LOGGER.debug("OpenCL: Using CLPlatform {} on device CLDevice {}", device.getPlatform(), device);
+                    activeInstance = new OpenCompute(device);
+                } else {
+                    LOGGER.info("OpenCL: OpenCL is not faster disabling OpenCL");
+                    YatopiaConfig.useOpenCL = false;
+                    activeInstance = null;
+                }
+
+            }
+        }
+    }
+
+    /**
+     * Calculates the number of work groups.
+     *
+     * @param size the total number of local work units
+     * @return the number of work groups
+     */
+    public int getGlobalSize(int size) {
+        return getGlobalSize(size, getLocalSize());
+    }
+
+    /**
+     * Calculates the number of work groups.
+     *
+     * @param size          the total number of local work units
+     * @param localWorkSize the number of local work units per work group
+     * @return the number of work groups
+     */
+    private static int getGlobalSize(int size, int localWorkSize) {
+        int globalSize = size;
+        int r = globalSize % localWorkSize;
+        if (r != 0) {
+            globalSize += localWorkSize - r;
+        }
+        return globalSize;
+    }
+
+    /**
+     * Calculates the number of local work units per work group.
+     *
+     * @return the size of the work groups
+     */
+    public int getLocalSize() {
+        return Math.min(device.getMaxWorkGroupSize(), 256);
+    }
+
+    /**
+     * Calculates the number of local work units per work group, applying a specified maximum.
+     *
+     * @param max the maximum size allowed
+     * @return the size of the work groups
+     */
+    public int getLocalSize(int max) {
+        return Math.min(device.getMaxWorkGroupSize(), max);
+    }
+
+    /**
+     * Static de-initializer. Clears all references to {@link CLProgram}, {@link CLKernel} and
+     * {@link CLContext} instances.
+     */
+    @Override
+    public synchronized void close() {
+        programs.clear();
+        programs = null;
+        context.release();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index e3104fd23de7fc1dec6ee471377d86bb10cf95a5..d9ba1e3f0011d68a9199fc72a7e7b9ed9b33be2c 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -13,6 +13,7 @@ import java.util.logging.Logger;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import net.minecrell.terminalconsole.TerminalConsoleAppender; // Paper
+import net.yatopia.server.opencl.OpenCompute;
 
 public class Main {
     public static boolean useJline = true;
@@ -305,6 +306,7 @@ public class Main {
                 System.setProperty( "library.jansi.version", "Paper" ); // Paper - set meaningless jansi version to prevent git builds from crashing on Windows
                 //de.minebench.origami.OrigamiConfig.init((java.io.File) options.valueOf("origami-settings")); // Origami - Server Config // Yatopia - no load here for u
                 System.out.println("Loading libraries, please wait...");
+                OpenCompute.init(); // Yatopia
                 net.minecraft.server.Main.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
diff --git a/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl b/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl
new file mode 100644
index 0000000000000000000000000000000000000000..f3deb06b5b51efbce68a450e58e4ad0359934023
--- /dev/null
+++ b/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl
@@ -0,0 +1,8 @@
+__kernel void test(__global const long *o1, __global const long *o2,
+                   __global long *result) {
+  int current = get_global_id(0);
+
+  result[current] = ((o1[current] * current) << 2) +
+                    (o2[current] % 2) / (current + 1) +
+                    (current >> 2) / ((current + 1) << 4);
+}
diff --git a/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java b/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..c0fa8e93ab521b98261ab4e8ae6a0693550069f8
--- /dev/null
+++ b/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java
@@ -0,0 +1,16 @@
+package net.yatopia.server.opencl;
+
+import junit.framework.TestCase;
+import net.yatopia.server.YatopiaConfig;
+
+public class OpenComputeTest extends TestCase {
+
+    public void testInitDefault() {
+        YatopiaConfig.openCLOverride = true;
+        OpenCompute.init();
+        if(OpenCompute.getActiveInstance() == null)
+            System.out.println("[WARN] OpenCL service not started");
+        OpenCompute.release();
+    }
+
+}
\ No newline at end of file
