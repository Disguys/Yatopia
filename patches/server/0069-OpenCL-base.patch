From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sun, 11 Oct 2020 12:30:35 +0800
Subject: [PATCH] OpenCL base

Patch used for OpenCL computing
Using GlowStoneMC implementation of OpenCompute API with JOCL

diff --git a/pom.xml b/pom.xml
index 4e9dfd79751fbf5c926c9683a2c8bb2800c60f0c..78be7c38d1a5a10a8638c5cdc2ab826cb4ece5a0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -111,6 +111,17 @@
             <artifactId>netty-all</artifactId>
             <version>4.1.50.Final</version>
         </dependency>
+        <!-- OpenCL -->
+        <dependency>
+            <groupId>org.jogamp.gluegen</groupId>
+            <artifactId>gluegen-rt-main</artifactId>
+            <version>2.3.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jogamp.jocl</groupId>
+            <artifactId>jocl-main</artifactId>
+            <version>2.3.2</version>
+        </dependency>
         <!-- deprecated API depend -->
         <dependency>
             <groupId>com.googlecode.json-simple</groupId>
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c3b2a77300bce04139741c8d79bb7c0d8199f403..09982930f614a49961fd116c9c59852b4cd0037f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -56,6 +56,8 @@ import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import net.yatopia.server.opencl.OpenCompute;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -838,6 +840,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         LOGGER.info("Closing Thread Pool");
         SystemUtils.shutdownServerThreadPool(); // Paper
         LOGGER.info("Closing Server");
+        OpenCompute.release(); // Yatopia
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
         } catch (Exception e) {
diff --git a/src/main/java/net/yatopia/server/YatopiaConfig.java b/src/main/java/net/yatopia/server/YatopiaConfig.java
index 893487d52aa58f4360cadfb83f87cf9d8396134e..3fc95746c29d38aabb6a174eee7190dcf43e846d 100644
--- a/src/main/java/net/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/net/yatopia/server/YatopiaConfig.java
@@ -256,12 +256,21 @@ public class YatopiaConfig {
     }
 
     public static LightEngineType lightEngineType = LightEngineType.VANILLA;
+
     private static void lightEngineType() {
         String type = getString("settings.light-engine.type", lightEngineType.name());
         try {
             lightEngineType = LightEngineType.valueOf(type);
-        } catch (IllegalArgumentException e){
+        } catch (IllegalArgumentException e) {
             Bukkit.getLogger().warning("Could not detect light engine type from \"" + type + "\", fallback to default " + lightEngineType.name());
         }
     }
+
+    public static boolean useOpenCL = true;
+    public static int openCLDeviceOverride = -1;
+
+    private static void openCL() {
+        useOpenCL = getBoolean("settings.opencl.enabled", useOpenCL);
+        openCLDeviceOverride = getInt("settings.opencl.device-override", openCLDeviceOverride);
+    }
 }
diff --git a/src/main/java/net/yatopia/server/opencl/OpenCompute.java b/src/main/java/net/yatopia/server/opencl/OpenCompute.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2bbdb955706f57a7c094cd1205b2c94254cfd2b
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/OpenCompute.java
@@ -0,0 +1,291 @@
+/*
+ * Glowstone Copyright (C) 2015-2020 The Glowstone Project.
+ * Glowstone Copyright (C) 2011-2014 Tad Hardesty.
+ * Lightstone Copyright (C) 2010-2011 Graham Edgecombe.
+ */
+
+package net.yatopia.server.opencl;
+
+import com.jogamp.opencl.CLCommandQueue;
+import com.jogamp.opencl.CLContext;
+import com.jogamp.opencl.CLDevice;
+import com.jogamp.opencl.CLKernel;
+import com.jogamp.opencl.CLPlatform;
+import com.jogamp.opencl.CLProgram;
+import com.jogamp.opencl.llb.impl.CLAbstractImpl;
+import net.yatopia.server.YatopiaConfig;
+import net.yatopia.server.list.GlueList;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class OpenCompute implements Closeable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static final ClassLoader CLASS_LOADER = OpenCompute.class.getClassLoader();
+    private File openCLDir;
+    private CLPlatform platform;
+    private CLContext context;
+    private CLDevice device;
+    private CLCommandQueue queue;
+    private ConcurrentHashMap<String, CLProgram> programs;
+    private ConcurrentHashMap<CLProgram, HashMap<String, CLKernel>> kernels;
+
+    private static OpenCompute activeInstance = null;
+
+    public static OpenCompute getActiveInstance() {
+        return activeInstance;
+    }
+
+    public static synchronized void release() {
+        activeInstance.close();
+        activeInstance = null;
+    }
+
+    public CLPlatform getPlatform() {
+        return platform;
+    }
+
+    public CLContext getContext() {
+        return context;
+    }
+
+    public CLDevice getDevice() {
+        return device;
+    }
+
+    public CLCommandQueue getQueue() {
+        return queue;
+    }
+
+    /**
+     * Initializes the {@link CLContext}, {@link CLDevice} and {@link CLCommandQueue} for the given
+     * {@link CLPlatform}.
+     *
+     * @param device the {@link CLDevice} to use
+     */
+    private OpenCompute(CLDevice device) {
+        openCLDir = new File("opencl");
+
+        if (!openCLDir.isDirectory() && !openCLDir.mkdirs()) {
+            LOGGER.fatal("Cannot create OpenCL directory");
+        }
+
+        programs = new ConcurrentHashMap<>();
+        kernels = new ConcurrentHashMap<>();
+        platform = device.getPlatform();
+        context = CLContext.create(device);
+        this.device = device;
+        queue = device.createCommandQueue();
+
+        LOGGER.info("OpenCL: Using " + platform + " on device " + device + ".");
+    }
+
+    /**
+     * Returns an OpenCL program, loading it synchronously if it's not in cache.
+     *
+     * @param name the program filename
+     * @return the OpenCL program, or null if there isn't a valid program with that name
+     */
+    public CLProgram getProgram(String name) {
+        if (programs.containsKey(name)) {
+            return programs.get(name);
+        } else {
+            if (openCLDir.exists() && openCLDir.isDirectory()) {
+                File file = new File(openCLDir, name);
+                if (file.exists()) {
+                    try (InputStream input = new FileInputStream(file)) {
+                        CLProgram program = context.createProgram(input).build();
+                        programs.put(name, program);
+                        return program;
+                    } catch (IOException ex) {
+                        LOGGER.log(Level.WARN,
+                                "Could not load custom OpenCL program.", ex);
+                    }
+                } else {
+                    try (InputStream input = CLASS_LOADER
+                            .getResourceAsStream("builtin/opencl/" + name)) {
+                        CLProgram program = context.createProgram(input).build();
+                        programs.put(name, program);
+                        return program;
+                    } catch (IOException ex) {
+                        LOGGER.log(Level.WARN,
+                                "Could not load builtin OpenCL program.", ex);
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    public CLKernel getKernel(CLProgram program, String name) {
+        return getKernel(program, name, true);
+    }
+
+    /**
+     * Returns a {@link CLKernel} that is part of the given {@link CLProgram}.
+     *
+     * @param program  the {@link CLProgram} that contains the kernel
+     * @param name     the name of the kernel
+     * @param threaded if true, always create a new {@link CLKernel} instance
+     * @return the {@link CLKernel}
+     */
+    public CLKernel getKernel(CLProgram program, String name, boolean threaded) {
+        if (kernels.containsKey(program)) {
+            HashMap<String, CLKernel> kernel = kernels.get(program);
+            if (kernel.containsKey(name) && !threaded) {
+                return kernel.get(name);
+            } else {
+                CLKernel clKernel = program.createCLKernel(name);
+                kernel.put(name, clKernel);
+                return clKernel;
+            }
+        } else {
+            kernels.put(program, new HashMap<>());
+            CLKernel clKernel = program.createCLKernel(name);
+            kernels.get(program).put(name, clKernel);
+            return clKernel;
+        }
+    }
+
+    /**
+     * Initializes OpenCompute API with settings defined in yatopia.yml
+     */
+    public static synchronized void init() {
+        if (YatopiaConfig.useOpenCL) {
+            if (!CLAbstractImpl.isAvailable()) {
+                LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                        "See if driver updates are available.");
+                return;
+            }
+
+            CLPlatform[] platforms = CLPlatform.listCLPlatforms();
+            LOGGER.info(String.format("Found %d platforms", platforms.length));
+            List<CLDevice> devices = new GlueList<>();
+            for (int i = 0; i < platforms.length; i++) {
+                CLPlatform platform = platforms[i];
+                LOGGER.info("Platform {}: Vendor string: {} ", i, platform.getVendor());
+                LOGGER.info("Platform {}: Profile string: {}", i, platform.getProfile());
+                LOGGER.info("Platform {}: Version string: {} ", i, platform.getVersion());
+                LOGGER.info("Platform {}: Name string: {} ", i, platform.getName());
+                LOGGER.info("Platform {}: Available extensions: {} ", i, platform.getExtensions());
+                CLDevice[] platformDevices = platform.listCLDevices();
+                devices.addAll(Arrays.asList(platformDevices));
+            }
+
+            LOGGER.info("Found {} devices", devices.size());
+
+            for (int i = 0, deviceCount = devices.size(); i < deviceCount; i++) {
+                CLDevice device = devices.get(i);
+                CLPlatform platform = device.getPlatform();
+                int platformID = -1;
+                for (int j = 0; j < platforms.length; j++)
+                    if (platforms[j] == platform) {
+                        platformID = j;
+                        break;
+                    }
+                LOGGER.info("Device {} of Platform {}: Name string: {} ", i, platformID, device.getName());
+                LOGGER.info("Device {} of Platform {}: Version string: {} ", i, platformID, device.getVersion());
+                LOGGER.info("Device {} of Platform {}: C-Version string: {} ", i, platformID, device.getCVersion());
+                LOGGER.info("Device {} of Platform {}: Driver version string: {} ", i, platformID, device.getDriverVersion());
+                LOGGER.info("Device {} of Platform {}: Profile string: {} ", i, platformID, device.getProfile());
+                LOGGER.info("Device {} of Platform {}: Device type: {} ", i, platformID, device.getType());
+                LOGGER.info("Device {} of Platform {}: Available extensions: {}", i, platformID, device.getExtensions());
+                LOGGER.info("Device {} of Platform {}: Execution capabilities: {}", i, platformID, device.getExecutionCapabilities());
+                LOGGER.info("Device {} of Platform {}: Maximum computing power: {} * {} = {}", i, platformID, device.getMaxComputeUnits(), device.getMaxClockFrequency(),device.getMaxComputeUnits() * device.getMaxWorkGroupSize() * device.getMaxClockFrequency());
+            }
+
+            if (YatopiaConfig.openCLDeviceOverride < -1 || YatopiaConfig.openCLDeviceOverride >= devices.size()) {
+                LOGGER.warn("Invalid override in configuration, ignoring");
+                YatopiaConfig.openCLDeviceOverride = -1;
+            }
+            if (YatopiaConfig.openCLDeviceOverride != -1) {
+                LOGGER.info("Overrides detected, using device {}", YatopiaConfig.openCLDeviceOverride);
+                activeInstance = new OpenCompute(devices.get(YatopiaConfig.openCLDeviceOverride));
+            } else {
+                LOGGER.info("No overrides defined, sorting devices by maximum computing power...");
+                devices.sort((o1, o2) -> {
+                    int flops1 = o1.getMaxComputeUnits() * o1.getMaxClockFrequency();
+                    int flops2 = o2.getMaxComputeUnits() * o2.getMaxClockFrequency();
+                    return -Integer.compare(flops1, flops2);
+                });
+                activeInstance = new OpenCompute(devices.get(0));
+            }
+        }
+    }
+
+    /**
+     * Calculates the number of work groups.
+     *
+     * @param size the total number of local work units
+     * @return the number of work groups
+     */
+    public int getGlobalSize(int size) {
+        return getGlobalSize(size, getLocalSize());
+    }
+
+    /**
+     * Calculates the number of work groups.
+     *
+     * @param size          the total number of local work units
+     * @param localWorkSize the number of local work units per work group
+     * @return the number of work groups
+     */
+    private static int getGlobalSize(int size, int localWorkSize) {
+        int globalSize = size;
+        int r = globalSize % localWorkSize;
+        if (r != 0) {
+            globalSize += localWorkSize - r;
+        }
+        return globalSize;
+    }
+
+    /**
+     * Calculates the number of local work units per work group.
+     *
+     * @return the size of the work groups
+     */
+    public int getLocalSize() {
+        return Math.min(device.getMaxWorkGroupSize(), 256);
+    }
+
+    /**
+     * Calculates the number of local work units per work group, applying a specified maximum.
+     *
+     * @param max the maximum size allowed
+     * @return the size of the work groups
+     */
+    public int getLocalSize(int max) {
+        return Math.min(device.getMaxWorkGroupSize(), max);
+    }
+
+    /**
+     * Static de-initializer. Clears all references to {@link CLProgram}, {@link CLKernel} and
+     * {@link CLContext} instances.
+     */
+    @Override
+    public synchronized void close() {
+        LOGGER.info("OpenCL: Shutting down");
+        programs.clear();
+        programs = null;
+        kernels.clear();
+        kernels = null;
+        context.release();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index e3104fd23de7fc1dec6ee471377d86bb10cf95a5..d9ba1e3f0011d68a9199fc72a7e7b9ed9b33be2c 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -13,6 +13,7 @@ import java.util.logging.Logger;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import net.minecrell.terminalconsole.TerminalConsoleAppender; // Paper
+import net.yatopia.server.opencl.OpenCompute;
 
 public class Main {
     public static boolean useJline = true;
@@ -305,6 +306,7 @@ public class Main {
                 System.setProperty( "library.jansi.version", "Paper" ); // Paper - set meaningless jansi version to prevent git builds from crashing on Windows
                 //de.minebench.origami.OrigamiConfig.init((java.io.File) options.valueOf("origami-settings")); // Origami - Server Config // Yatopia - no load here for u
                 System.out.println("Loading libraries, please wait...");
+                OpenCompute.init(); // Yatopia
                 net.minecraft.server.Main.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
diff --git a/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl b/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java b/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f267576b547cb25a9e5bcc191629072324c5432
--- /dev/null
+++ b/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java
@@ -0,0 +1,14 @@
+package net.yatopia.server.opencl;
+
+import junit.framework.TestCase;
+
+public class OpenComputeTest extends TestCase {
+
+    public void testInitDefault() {
+        OpenCompute.init();
+        if(OpenCompute.getActiveInstance() != null)
+            System.out.println("[WARN] OpenCL service not started");
+        OpenCompute.release();
+    }
+
+}
\ No newline at end of file
