From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sun, 11 Oct 2020 12:30:35 +0800
Subject: [PATCH] OpenCL base

Patch used for OpenCL computing
Using GlowStoneMC implementation of OpenCompute API with JOCL

diff --git a/pom.xml b/pom.xml
index 4e9dfd79751fbf5c926c9683a2c8bb2800c60f0c..78be7c38d1a5a10a8638c5cdc2ab826cb4ece5a0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -111,6 +111,17 @@
             <artifactId>netty-all</artifactId>
             <version>4.1.50.Final</version>
         </dependency>
+        <!-- OpenCL -->
+        <dependency>
+            <groupId>org.jogamp.gluegen</groupId>
+            <artifactId>gluegen-rt-main</artifactId>
+            <version>2.3.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jogamp.jocl</groupId>
+            <artifactId>jocl-main</artifactId>
+            <version>2.3.2</version>
+        </dependency>
         <!-- deprecated API depend -->
         <dependency>
             <groupId>com.googlecode.json-simple</groupId>
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c3b2a77300bce04139741c8d79bb7c0d8199f403..09982930f614a49961fd116c9c59852b4cd0037f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -56,6 +56,8 @@ import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import net.yatopia.server.opencl.OpenCompute;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -838,6 +840,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         LOGGER.info("Closing Thread Pool");
         SystemUtils.shutdownServerThreadPool(); // Paper
         LOGGER.info("Closing Server");
+        OpenCompute.release(); // Yatopia
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
         } catch (Exception e) {
diff --git a/src/main/java/net/yatopia/server/YatopiaConfig.java b/src/main/java/net/yatopia/server/YatopiaConfig.java
index 893487d52aa58f4360cadfb83f87cf9d8396134e..3fc95746c29d38aabb6a174eee7190dcf43e846d 100644
--- a/src/main/java/net/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/net/yatopia/server/YatopiaConfig.java
@@ -256,12 +256,21 @@ public class YatopiaConfig {
     }
 
     public static LightEngineType lightEngineType = LightEngineType.VANILLA;
+
     private static void lightEngineType() {
         String type = getString("settings.light-engine.type", lightEngineType.name());
         try {
             lightEngineType = LightEngineType.valueOf(type);
-        } catch (IllegalArgumentException e){
+        } catch (IllegalArgumentException e) {
             Bukkit.getLogger().warning("Could not detect light engine type from \"" + type + "\", fallback to default " + lightEngineType.name());
         }
     }
+
+    public static boolean useOpenCL = true;
+    public static int openCLDeviceOverride = -1;
+
+    private static void openCL() {
+        useOpenCL = getBoolean("settings.opencl.enabled", useOpenCL);
+        openCLDeviceOverride = getInt("settings.opencl.device-override", openCLDeviceOverride);
+    }
 }
diff --git a/src/main/java/net/yatopia/server/opencl/BasicBenchmark.java b/src/main/java/net/yatopia/server/opencl/BasicBenchmark.java
new file mode 100644
index 0000000000000000000000000000000000000000..a85d3728cc03f4f45b38d97667155c99cf6cd5a9
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/BasicBenchmark.java
@@ -0,0 +1,83 @@
+package net.yatopia.server.opencl;
+
+import com.jogamp.opencl.CLBuffer;
+import com.jogamp.opencl.CLCommandQueue;
+import com.jogamp.opencl.CLEventList;
+import com.jogamp.opencl.CLKernel;
+import com.jogamp.opencl.CLProgram;
+import com.jogamp.opencl.CLUserEvent;
+
+import java.nio.LongBuffer;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+
+import static com.jogamp.opencl.CLEvent.ProfilingCommand.*;
+
+public class BasicBenchmark {
+
+    private static int WORK_SIZE = 1048576;
+
+    public static CompletableFuture<BenchmarkResult> benchmark(OpenCompute openCompute) {
+        CompletableFuture<BenchmarkResult> future = new CompletableFuture<>();
+        OpenCompute.OPENCL_EXECUTOR.execute(() -> {
+            final long[] testData1 = new long[WORK_SIZE];
+            final long[] testData2 = new long[WORK_SIZE];
+            Random random = new Random();
+            for (int i = 0; i < WORK_SIZE; i++) {
+                testData1[i] = random.nextLong();
+                testData2[i] = random.nextLong();
+            }
+            CLProgram program = openCompute.getProgram("net/yatopia/server/opencl/SpeedTest.cl");
+            long startTime = System.nanoTime();
+            CLBuffer<LongBuffer> longBuffer1 = null;
+            CLBuffer<LongBuffer> longBuffer2 = null;
+            CLBuffer<LongBuffer> longBuffer3 = null;
+            CLKernel kernel = null;
+            CLEventList events = null;
+            try {
+                longBuffer1 = openCompute.getContext().createLongBuffer(WORK_SIZE);
+                longBuffer2 = openCompute.getContext().createLongBuffer(WORK_SIZE);
+                longBuffer3 = openCompute.getContext().createLongBuffer(WORK_SIZE);
+                longBuffer1.getBuffer().put(testData1);
+                longBuffer2.getBuffer().put(testData2);
+                kernel = openCompute.getKernel(program, "test");
+                kernel.putArg(longBuffer1)
+                        .putArg(longBuffer2)
+                        .putArg(longBuffer3);
+                CLCommandQueue clCommandQueue = openCompute.getQueue();
+                events = new CLEventList(null, 1);
+                clCommandQueue.put1DRangeKernel(kernel, 0,
+                        openCompute.getGlobalSize(WORK_SIZE), openCompute.getLocalSize(), events)
+                        .putReadBuffer(longBuffer3, true)
+                        .putWaitForEvents(events, true);
+
+                long gpuTiming = events.getEvent(0).getProfilingInfo(END) - events.getEvent(0).getProfilingInfo(START);
+                long cpuTiming = System.nanoTime() - startTime;
+                future.complete(new BenchmarkResult(gpuTiming, cpuTiming, openCompute));
+            } catch (Throwable t) {
+                future.completeExceptionally(t);
+            } finally {
+                if (longBuffer1 != null && !longBuffer1.isReleased()) longBuffer1.release();
+                if (longBuffer2 != null && !longBuffer2.isReleased()) longBuffer2.release();
+                if (longBuffer3 != null && !longBuffer3.isReleased()) longBuffer3.release();
+                if (kernel != null && !kernel.isReleased()) kernel.release();
+                if (events != null && !events.isReleased()) events.release();
+            }
+
+        });
+        return future;
+    }
+
+    public static class BenchmarkResult {
+        public final long gpuTiming;
+        public final long cpuTiming;
+        public final OpenCompute openCompute;
+
+        private BenchmarkResult(long gpuTiming, long cpuTiming, OpenCompute openCompute) {
+            this.gpuTiming = gpuTiming;
+            this.cpuTiming = cpuTiming;
+            this.openCompute = openCompute;
+        }
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/opencl/OpenCompute.java b/src/main/java/net/yatopia/server/opencl/OpenCompute.java
new file mode 100644
index 0000000000000000000000000000000000000000..16dc0a19eb5137c5444e06718c64c42f749b7a4c
--- /dev/null
+++ b/src/main/java/net/yatopia/server/opencl/OpenCompute.java
@@ -0,0 +1,316 @@
+/*
+ * Glowstone Copyright (C) 2015-2020 The Glowstone Project.
+ * Glowstone Copyright (C) 2011-2014 Tad Hardesty.
+ * Lightstone Copyright (C) 2010-2011 Graham Edgecombe.
+ */
+
+package net.yatopia.server.opencl;
+
+import com.jogamp.opencl.CLCommandQueue;
+import com.jogamp.opencl.CLContext;
+import com.jogamp.opencl.CLDevice;
+import com.jogamp.opencl.CLKernel;
+import com.jogamp.opencl.CLPlatform;
+import com.jogamp.opencl.CLProgram;
+import com.jogamp.opencl.llb.impl.CLAbstractImpl;
+import net.yatopia.server.YatopiaConfig;
+import net.yatopia.server.list.GlueList;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+
+public class OpenCompute implements Closeable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final ClassLoader CLASS_LOADER = OpenCompute.class.getClassLoader();
+    static final ExecutorService OPENCL_EXECUTOR = Executors.newCachedThreadPool(new ThreadFactory() {
+        private AtomicLong serial = new AtomicLong(0);
+
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread thread = new Thread(r);
+            thread.setName("YatopiaCL-" + serial.getAndIncrement());
+            thread.setPriority(Thread.NORM_PRIORITY - 1);
+            thread.setDaemon(true);
+            return thread;
+        }
+    });
+
+    private final File openCLDir;
+    private final CLPlatform platform;
+    private final CLContext context;
+    private final CLDevice device;
+    private final CLCommandQueue queue;
+    private ConcurrentHashMap<String, CLProgram> programs;
+
+    private static OpenCompute activeInstance = null;
+
+    public static OpenCompute getActiveInstance() {
+        return activeInstance;
+    }
+
+    public static synchronized void release() {
+        LOGGER.info("Yatopia OpenCL: Shutting down");
+        if (activeInstance != null)
+            activeInstance.close();
+        activeInstance = null;
+    }
+
+    public CLPlatform getPlatform() {
+        return platform;
+    }
+
+    public CLContext getContext() {
+        return context;
+    }
+
+    public CLDevice getDevice() {
+        return device;
+    }
+
+    public CLCommandQueue getQueue() {
+        return queue;
+    }
+
+    /**
+     * Initializes the {@link CLContext}, {@link CLDevice} and {@link CLCommandQueue} for the given
+     * {@link CLPlatform}.
+     *
+     * @param device the {@link CLDevice} to use
+     */
+    private OpenCompute(CLDevice device) {
+        this(device, false);
+    }
+
+    private OpenCompute(CLDevice device, boolean profilingEnabled) {
+        openCLDir = new File("opencl");
+
+        programs = new ConcurrentHashMap<>();
+        platform = device.getPlatform();
+        context = CLContext.create(device);
+        this.device = device;
+        if (profilingEnabled)
+            queue = device.createCommandQueue(CLCommandQueue.Mode.PROFILING_MODE, CLCommandQueue.Mode.OUT_OF_ORDER_MODE);
+        else
+            queue = device.createCommandQueue(CLCommandQueue.Mode.OUT_OF_ORDER_MODE);
+    }
+
+    /**
+     * Returns an OpenCL program, loading it synchronously if it's not in cache.
+     *
+     * @param name the program filename
+     * @return the OpenCL program, or null if there isn't a valid program with that name
+     */
+    public CLProgram getProgram(String name) {
+        if (programs.containsKey(name)) {
+            return programs.get(name);
+        } else {
+            synchronized (this) {
+                if (programs.containsKey(name))
+                    return programs.get(name);
+                if (openCLDir.exists() && openCLDir.isDirectory()) {
+                    File file = new File(openCLDir, name);
+                    if (file.exists()) {
+                        try (InputStream input = new FileInputStream(file)) {
+                            CLProgram program = context.createProgram(input).build();
+                            programs.put(name, program);
+                            return program;
+                        } catch (IOException ex) {
+                            LOGGER.log(Level.WARN,
+                                    "Could not load custom OpenCL program.", ex);
+                        }
+                    }
+                }
+                try (InputStream input = CLASS_LOADER
+                        .getResourceAsStream("builtin/opencl/" + name)) {
+                    CLProgram program = context.createProgram(input).build();
+                    programs.put(name, program);
+                    return program;
+                } catch (IOException ex) {
+                    LOGGER.log(Level.WARN,
+                            "Could not load builtin OpenCL program.", ex);
+                }
+            }
+        }
+        return null;
+    }
+
+    public CLKernel getKernel(CLProgram program, String name) {
+        return program.createCLKernel(name);
+    }
+
+    /**
+     * Initializes OpenCompute API with settings defined in yatopia.yml
+     */
+    public static synchronized void init() {
+        if (YatopiaConfig.useOpenCL) {
+            LOGGER.info("Initializing OpenCL...");
+            if (!CLAbstractImpl.isAvailable()) {
+                LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                        "See if driver updates are available.");
+                return;
+            }
+
+            CLPlatform[] platforms = CLPlatform.listCLPlatforms();
+            LOGGER.info(String.format("Found %d platforms", platforms.length));
+            List<CLDevice> devices = new GlueList<>();
+            List<CompletableFuture<BasicBenchmark.BenchmarkResult>> deviceBenchmarks = new GlueList<>();
+            for (int i = 0; i < platforms.length; i++) {
+                CLPlatform platform = platforms[i];
+                LOGGER.info("Platform {}: Vendor string: {} ", i, platform.getVendor());
+                LOGGER.info("Platform {}: Profile string: {}", i, platform.getProfile());
+                LOGGER.info("Platform {}: Version string: {} ", i, platform.getVersion());
+                LOGGER.info("Platform {}: Name string: {} ", i, platform.getName());
+                LOGGER.info("Platform {}: Available extensions: {} ", i, platform.getExtensions());
+                CLDevice[] platformDevices = platform.listCLDevices();
+                devices.addAll(Arrays.asList(platformDevices));
+            }
+
+            LOGGER.info("Found {} devices", devices.size());
+            if (devices.isEmpty()) {
+                LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                        "See if driver updates are available.");
+                return;
+            }
+
+            for (int i = 0, deviceCount = devices.size(); i < deviceCount; i++) {
+                CLDevice device = devices.get(i);
+                CLPlatform platform = device.getPlatform();
+                int platformID = -1;
+                for (int j = 0; j < platforms.length; j++)
+                    if (platforms[j] == platform) {
+                        platformID = j;
+                        break;
+                    }
+                LOGGER.info("Device {} of Platform {}: Name string: {} ", i, platformID, device.getName());
+                LOGGER.info("Device {} of Platform {}: Version string: {} ", i, platformID, device.getVersion());
+                LOGGER.info("Device {} of Platform {}: C-Version string: {} ", i, platformID, device.getCVersion());
+                LOGGER.info("Device {} of Platform {}: Driver version string: {} ", i, platformID, device.getDriverVersion());
+                LOGGER.info("Device {} of Platform {}: Profile string: {} ", i, platformID, device.getProfile());
+                LOGGER.info("Device {} of Platform {}: Device type: {} ", i, platformID, device.getType());
+                LOGGER.info("Device {} of Platform {}: Available extensions: {}", i, platformID, device.getExtensions());
+                LOGGER.info("Device {} of Platform {}: Execution capabilities: {}", i, platformID, device.getExecutionCapabilities());
+            }
+
+            if (YatopiaConfig.openCLDeviceOverride < -1 || YatopiaConfig.openCLDeviceOverride >= devices.size()) {
+                LOGGER.warn("Invalid override in configuration, ignoring");
+                YatopiaConfig.openCLDeviceOverride = -1;
+            }
+            if (YatopiaConfig.openCLDeviceOverride != -1) {
+                LOGGER.info("Overrides detected, using device {}", YatopiaConfig.openCLDeviceOverride);
+                activeInstance = new OpenCompute(devices.get(YatopiaConfig.openCLDeviceOverride));
+            } else {
+                LOGGER.info("No overrides defined, sorting devices by benchmark results...");
+                for (CLDevice device : devices) {
+                    OpenCompute openCompute = new OpenCompute(device, true);
+                    deviceBenchmarks.add(BasicBenchmark.benchmark(openCompute).handle((benchmarkResult, throwable) -> {
+                        if (throwable != null)
+                            LOGGER.info("A device failed to benchmark, device information unavailable", throwable);
+                        openCompute.close();
+                        return benchmarkResult;
+                    }));
+                }
+                deviceBenchmarks.sort((o1, o2) -> {
+                    BasicBenchmark.BenchmarkResult benchmarkResult1 = o1.join();
+                    BasicBenchmark.BenchmarkResult benchmarkResult2 = o2.join();
+                    int gpuTimingCompare = Long.compare(benchmarkResult1.gpuTiming, benchmarkResult2.gpuTiming);
+                    int cpuTimingCompare = Long.compare(benchmarkResult1.cpuTiming, benchmarkResult2.cpuTiming);
+                    if (gpuTimingCompare != 0) return gpuTimingCompare;
+                    else return cpuTimingCompare;
+                });
+                deviceBenchmarks.removeIf(future -> future.join() == null);
+
+                if (deviceBenchmarks.isEmpty()) {
+                    LOGGER.warn("Your system does not meet the OpenCL requirements for Yatopia OpenCL Acceleration. " +
+                            "See if driver updates are available.");
+                    return;
+                }
+
+                LOGGER.info("Benchmark results: ");
+                for (int i = 0, size = deviceBenchmarks.size(); i < size; i++) {
+                    BasicBenchmark.BenchmarkResult benchmarkResult = deviceBenchmarks.get(i).join();
+                    LOGGER.info("{}: {}ms, {}ms: CLPlatform {} on device CLDevice {}",
+                            i + 1, benchmarkResult.gpuTiming / 1_000_000.0, benchmarkResult.cpuTiming / 1_000_000.0,
+                            benchmarkResult.openCompute.getPlatform(), benchmarkResult.openCompute.getDevice());
+                }
+                CLDevice device = deviceBenchmarks.get(0).join().openCompute.device;
+                LOGGER.info("OpenCL: Using CLPlatform {} on device CLDevice {}", device.getPlatform(), device);
+                activeInstance = new OpenCompute(device);
+            }
+        }
+    }
+
+    /**
+     * Calculates the number of work groups.
+     *
+     * @param size the total number of local work units
+     * @return the number of work groups
+     */
+    public int getGlobalSize(int size) {
+        return getGlobalSize(size, getLocalSize());
+    }
+
+    /**
+     * Calculates the number of work groups.
+     *
+     * @param size          the total number of local work units
+     * @param localWorkSize the number of local work units per work group
+     * @return the number of work groups
+     */
+    private static int getGlobalSize(int size, int localWorkSize) {
+        int globalSize = size;
+        int r = globalSize % localWorkSize;
+        if (r != 0) {
+            globalSize += localWorkSize - r;
+        }
+        return globalSize;
+    }
+
+    /**
+     * Calculates the number of local work units per work group.
+     *
+     * @return the size of the work groups
+     */
+    public int getLocalSize() {
+        return Math.min(device.getMaxWorkGroupSize(), 256);
+    }
+
+    /**
+     * Calculates the number of local work units per work group, applying a specified maximum.
+     *
+     * @param max the maximum size allowed
+     * @return the size of the work groups
+     */
+    public int getLocalSize(int max) {
+        return Math.min(device.getMaxWorkGroupSize(), max);
+    }
+
+    /**
+     * Static de-initializer. Clears all references to {@link CLProgram}, {@link CLKernel} and
+     * {@link CLContext} instances.
+     */
+    @Override
+    public synchronized void close() {
+        programs.clear();
+        programs = null;
+        context.release();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index e3104fd23de7fc1dec6ee471377d86bb10cf95a5..d9ba1e3f0011d68a9199fc72a7e7b9ed9b33be2c 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -13,6 +13,7 @@ import java.util.logging.Logger;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import net.minecrell.terminalconsole.TerminalConsoleAppender; // Paper
+import net.yatopia.server.opencl.OpenCompute;
 
 public class Main {
     public static boolean useJline = true;
@@ -305,6 +306,7 @@ public class Main {
                 System.setProperty( "library.jansi.version", "Paper" ); // Paper - set meaningless jansi version to prevent git builds from crashing on Windows
                 //de.minebench.origami.OrigamiConfig.init((java.io.File) options.valueOf("origami-settings")); // Origami - Server Config // Yatopia - no load here for u
                 System.out.println("Loading libraries, please wait...");
+                OpenCompute.init(); // Yatopia
                 net.minecraft.server.Main.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
diff --git a/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl b/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl
new file mode 100644
index 0000000000000000000000000000000000000000..f3deb06b5b51efbce68a450e58e4ad0359934023
--- /dev/null
+++ b/src/main/resources/builtin/opencl/net/yatopia/server/opencl/SpeedTest.cl
@@ -0,0 +1,8 @@
+__kernel void test(__global const long *o1, __global const long *o2,
+                   __global long *result) {
+  int current = get_global_id(0);
+
+  result[current] = ((o1[current] * current) << 2) +
+                    (o2[current] % 2) / (current + 1) +
+                    (current >> 2) / ((current + 1) << 4);
+}
diff --git a/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java b/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c1a7955a0738e3103dc8d4ccddda673345c4b92
--- /dev/null
+++ b/src/test/java/net/yatopia/server/opencl/OpenComputeTest.java
@@ -0,0 +1,14 @@
+package net.yatopia.server.opencl;
+
+import junit.framework.TestCase;
+
+public class OpenComputeTest extends TestCase {
+
+    public void testInitDefault() {
+        OpenCompute.init();
+        if(OpenCompute.getActiveInstance() == null)
+            System.out.println("[WARN] OpenCL service not started");
+        OpenCompute.release();
+    }
+
+}
\ No newline at end of file
